#include <iostream>
#include <random>
#include <sstream>
#include <assert.h>
#include "BST.hpp"
#include "helper.h"

using namespace std;

#define NOPS 10000
#define NSECONDS 1
/*
 * 0 == no locks
 * 1 == locks
 * 2 == HLE
 * 3 == RTM
 */
#define TREE_TYPE 2

/*
 * Global Variables
 */

//Tupple: <Lower bound, Upper bound, the power of 2 that will generate the range defined by lower and upper bounds
std::vector<std::tuple<int, int, int>> bounds = {std::tuple<int, int, int>(0, 15, 4),
                                                 std::tuple<int, int, int>(0, 255, 8),
                                                 std::tuple<int, int, int>(0, 4095, 12),
                                                 std::tuple<int, int, int>(0, 65535, 16),
                                                 std::tuple<int, int, int>(0, 1048575, 20)};
int currentBound;
BinarySearchTree *tree;
UINT64 *numberOfOpsPerThread;

void prepareTree();

unsigned long long int generateRanom(mt19937 *generator, int uBound, int lBound) {

    return 0;
}

WORKER worker(void *vthread) {
    int tid = (int) ((size_t) vthread);
    /*
     * Create a thread local random number generator
     */
    std::random_device rd;
    std::default_random_engine e1(rd());
    std::uniform_int_distribution<int> uniform_dist(std::get<0>(bounds[currentBound]),
                                                    std::get<1>(bounds[currentBound]));

    UINT64 tstart;
    UINT64 ops = 0;
    tstart = getWallClockMS();
    while (1) {
        for (int i = 0; i < NOPS; i++) {
            UINT64 value = (unsigned long long int) uniform_dist(e1);
            if (value & 1) {
#if TREE_TYPE == 0
                (*tree).insert(value);
#elif TREE_TYPE == 1
                (*tree).insertWithTestAndTestAndSetLock(value);
#elif TREE_TYPE == 2
                (*tree).insertWithHLE(value);
#elif TREE_TYPE ==3
                (*tree).insertWithRTM(value);
#endif
            } else {
#if TREE_TYPE == 0
                (*tree).insert(value);
#elif TREE_TYPE == 1
                (*tree).insertWithTestAndTestAndSetLock(value);
#elif TREE_TYPE == 2
                (*tree).insertWithHLE(value);
#elif TREE_TYPE ==3
                (*tree).insertWithRTM(value);
#endif
            }
            continue;
        }
        ops += NOPS;
        if ((getWallClockMS() - tstart) > (NSECONDS * 1000)) {
            break;
        }
    }
    numberOfOpsPerThread[tid] = ops;
    return nullptr;
}

/*
 * Function to print numbers with commans in them
 * Source: https://stackoverflow.com/questions/7276826/c-format-number-with-commas
 */
template<class T>
std::string FormatWithCommas(T value) {
    std::stringstream ss;
    ss.imbue(std::locale(""));
    ss << std::fixed << value;
    return ss.str();
}

void prepareTree(int iter) {
    /*
     * Create a new tree and check that its size is 0
     */
    tree = new BinarySearchTree();
    assert((*tree).isEmpty());

    /*
     * Add (2^iter)/2 nodes to the tree before we start
     * In order to make sure there is something to remove
     */
    iter = std::pow(2, iter) / 2;
    for (int i = 0; i < iter; i++) {
        std::random_device rd;
        std::default_random_engine e1(rd());
        std::uniform_int_distribution<int> uniform_dist(std::get<0>(bounds[currentBound]),
                                                        std::get<1>(bounds[currentBound]));
        UINT64 val = (unsigned long long int) uniform_dist(e1);
        tree->insert(val);
    }
}

/*
 * Main
 */
int main(int argc, char **argv) {
    using namespace std;
    cout << "Thread cound/Tree size at start/Tree size at end/Total operations" << endl;
    /*
     * Max threads is always the two times the number of CPU's
     */
    int maxThreads = getNumberOfCPUs() * 2;
    int totalOps;
    THREADH *threads;
    currentBound = 0;

    for (int boundSize = 0; boundSize < bounds.size(); boundSize++) {
        /*
         * Print the bounds of the values generated by the random number generator
         */
        cout << "Lower bound: " << std::get<0>(bounds[currentBound]) << " Upper Bound: " <<
        std::get<1>(bounds[currentBound]) << endl;

        for (unsigned int threadCount = 1; threadCount <= maxThreads; threadCount++) {

            /*
             * Create new variables for each iteration
             */
            prepareTree(std::get<2>(bounds[currentBound]));
            UINT64 treeSizeAtStart = tree->getSize();
            totalOps = 0;
            numberOfOpsPerThread = new UINT64[threadCount];
            threads = new THREADH[threadCount];

            /*
             * Check to makesure tree is empty before beginning
             */
            for (int threadNumber = 0; threadNumber < threadCount; threadNumber++) {
                createThread(&threads[threadNumber], worker, (void *) threadNumber);
            }

            /*
             * Wait for all threads to finish (Barrier)
             */
            waitForThreadsToFinish(threadCount, threads);

            /*
             * Sum the number of ops per thread
             */
            for (int j = 0; j < threadCount; j++) {
                totalOps += numberOfOpsPerThread[j];

            }
            /*
             * Print data
             */
            cout << threadCount << "/" << FormatWithCommas(treeSizeAtStart) << "/" <<
            FormatWithCommas((*tree).getSize()) << "/" << FormatWithCommas(totalOps) << endl;
        }
        currentBound++;
    }
}